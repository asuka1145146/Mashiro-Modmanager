
## 写在前面

**这个管理器是给已经会用管理器的老玩家，甚至 mod 作者准备的。**  
如果你从来没接触过 mod 管理器，或者连“启用/禁用 mod”是什么意思都不知道，建议先去用用狩技管理器，熟悉基本概念后再回来看这个。

---



## 先看看狩技管理器是怎么工作的

在介绍我的管理器之前，我们先看看市面上最流行的狩技管理器的工作原理：

先承认一点：**狩技管理器现在最大的优势，就是“一键替换套装/武器”这种内置功能真的很香。**  
对普通玩家来说，点几下就能把整套装备换成别的预设，体验非常顺滑。

但问题也刚好出在这里——

它只支持作者预先写死好的那几套“预设替换”：  
- 你想用它做更奇怪的替换（比如只改某个编号段，或者换成你自己字典里的一套），对不起，做不到；  
- 尤其我们这些做 mod 的，每天都在和各种文件格式打交道，就总有一种：  
  **“眼前就有一台最强的换装机，明明只差改一个字母，我就是用不上”的憋屈感。**

这也是我后来一定要把“自定义脚本”之类的东西做出来用的原因之一。

### 物理移动 + 覆盖机制

狩技管理器的工作方式很简单粗暴：

1. **启用 mod**：把 mod 文件从管理器目录**物理移动**到游戏目录。
2. **冲突处理**：如果两个 mod 修改了同一个文件，**后者将覆盖前者**——后启用的 mod 文件直接覆盖先启用的。
3. **禁用 mod**：把对应文件**直接从游戏目录删除**。

### 这个机制的问题

这种“物理移动 + 直接删除”的方式有几个明显的缺陷：

- **占用双倍空间**：mod 文件在管理器目录存一份，启用时又复制到游戏目录，同一份文件占了两份磁盘空间。
- **没有维护栈**：启用/禁用来回切换时，你根本不知道最后生效的是哪个 mod。比如：
  - 启用 A → 启用 B（B 覆盖 A）→ 禁用 B
  - 这时候游戏目录里可能还有 A 的文件，也可能已经被 B 覆盖了，**你根本搞不清当前状态**。
- **冲突处理混乱**：多个 mod 冲突时，只能靠“后启用覆盖先启用”这种简单粗暴的方式，没有优先级管理。

不小心手动往根目录装了个mod，不小心删了一个当时不想要的文件，再回mod盒子一用我还以为我犯了天条了，往往被诅咒————‘悔恨’了。

---

## 那 MO2 呢？

MO2（Mod Organizer 2）这类通用模组管理器功能非常强大，但：

- **学习曲线陡峭**：概念多、界面选项多，新手很难上手。
- **UI 风格老派**：整体感觉像上世纪的工具，和现在很多人喜欢的审美不太一样，兄弟我是真不想看。

---

当然这些可能都只是使用上的一点小问题，狩技和MO2等管理器真正的**原罪**在哪？
**居然没有我喜欢的马希洛元素！（恼）**。



## 我的管理器是怎么工作的？

上面说了别人的工作原理，下面说说我自己的：**核心是“文件栈 + 虚拟映射”**。

### 物理复制时的“文件栈”概念：用水井和石头的比喻

先假设你还是走传统的“物理复制”路线，我们用水井和石头的比喻来理解会发生什么：

想象游戏目录是一口**水井**，每个文件路径（比如 `nativePC/pl/f_equip/pl027_0500/model.mod3`）对应井底的一个位置。

- 你启用一个修改这个文件的 mod，相当于**往这个位置丢了一块新石头**，石头沉到井底，把原来的文件盖住了；
- 再启用另一个也改这个文件的 mod，又丢一块石头在上面，新石头盖住旧石头；
- 禁用最近启用的那个 mod，就是把**最上面那块石头捞出来**，下面那块又露出来了。

这就是“**文件栈**”的概念：每个路径对应一条栈，栈顶的石头（文件）就是当前生效的版本。

如果管理器没有在逻辑里维护这条“石头栈”，而只是物理复制和删除，那就会出现典型的混乱场景：

- 有些文件被你手动改过；
- 有些是早期某个 mod 留下来的残骸；
- 再叠一层新 mod 上去，删错一块石头，下面是啥你自己都说不清。

**我的管理器在逻辑层面明确把“每个路径对应一条栈”这件事记下来**，而不是只看“当前磁盘上有个文件”。  
这样一来，“谁覆盖了谁”“禁用后恢复到哪个版本”才有讨论空间。

### 虚拟映射：用水井和镜子的比喻

真正落到磁盘上的实现，我尽量避免再去“搬石头”（物理复制），而是用**虚拟映射**来做：

想象有两口水井：
- **一口是游戏根目录的水井**：里面是原版游戏文件，这口井我们**不动它**。
- **一口是 `mods/` 目录的水井**：里面堆着各个 mod 的“石头”（文件）。

传统做法是：真的把 `mods/` 井里的石头一块块搬到游戏根目录那口井里，用完再捞出来。

我的做法是：**在游戏根目录那口井里放一面镜子**。游戏“照镜子”时，看到的不是自己井里的原版文件，而是 `mods/` 那口井里的 mod 文件。

技术上就是：

- 所有真实文件都放在 `mods/` 下，各个 mod 各占一个子目录；
- 在游戏目录（或者一个虚拟目录）里，为需要生效的文件创建 **junction / 符号链接**（就是那面“镜子”）：
  - 游戏以为自己在读 `nativePC/.../xxx`；
  - 实际上读的是 `mods/某个mod/nativePC/.../xxx`；
- 启用某个 mod，相当于：在游戏根目录那口井里，把对应路径的“镜子”指向 `mods/` 井里的这个 mod，你可以想象成是创建了一个快捷方式或者一个指向它的指针吧；
- 禁用某个 mod，相当于：把这面镜子拿掉，**逻辑上的文件栈回退一层**，下一个优先级的链接（或者原版文件）生效。

好处是：

- 物理上**只有一份文件**，不会再出现“一份在盒子里、一份在游戏根目录”的尴尬；
- 逻辑上有“栈”的概念，谁覆盖谁、禁用之后回到谁，都有迹可循；
- 想“把游戏根目录那口井清空”也很简单：只要把镜子拆掉，`mods/` 井里的真实石头一块都没动，游戏根目录那口井也还是原样。

后面 README 再具体讲玩法时，你可以把脑子里的模型一直想成是这个“两口水井 + 镜子”的组合，就比较容易理解我一些设计上的取舍了。

---

## mod 作者最头疼的事：编号命名根本看不懂

如果你是一个 mod 作者，尤其是做替换类 mod 的，肯定遇到过这种情况：

游戏里很多文件路径都是用编号命名的，比如 `nativePC/pl/f_equip/pl027_0500`、`nativePC/wp/wp03/wp03_0010` 这种，**完全看不出来这串数字代表什么**。

你想做一个“把 A 套装替换成 B 套装”的 mod，但：
- 你不知道 `pl027_0500` 到底是哪套衣服；
- 你不知道 `pl033_0101` 又是哪套；
- 你更不知道这两套之间能不能替换、会不会出问题。

我自己就经常头疼，每次都要：
- 打开怪物猎人世界数据表 15.10.00 简中.xlsx查编号对应的含义；
- 甚至表里没有的编号，还得腆着脸去问其他作者“这个是什么啊？”。

**字典功能就是为了解决这个问题**：

- 字典就是一个“编号 → 人类能看懂的名字”的映射表，比如 `pl027_0500` → `精英·霜漂阿尔法`；
- 字典文件放在 `dictionary/` 目录下，是开放的 JSON 格式，谁都可以编辑、补充；
- 在编辑 mod 时，点击【使用字典】，文件树里那些 `pl027_0500` 就会显示成 `pl027_0500 (精英·霜漂阿尔法)`，一目了然；
- 这样你就不用每次都去翻表，也不用到处问人了。

---

## Python 脚本的困境

对开发者来说，Python 脚本超级好写，几行代码就能做个“批量重命名”工具。此外如果你闲的蛋疼，python 脚本甚至可以随便放音乐、视频，甚至在游戏里内嵌新游戏（比如贪吃蛇），python 的高集成度带来了极高的上限。

比如说我之前发过一个击杀怪物会触发动画的脚本，就是检测到游戏里怪物死亡就在屏幕上覆盖播放一段 gif，脚本实现不难，但是这个效果如果像 dll 一样内嵌到游戏中，那对 mod 作者很难做到了。

但现实是：**大部分玩家根本不会用 Python**：
- 他们会用 dll mod，会按说明书往游戏里丢文件，
- 但让他打开命令行、装 Python 第三方库、跑脚本，基本劝退；
- 结果就是：**好用的 Python 小工具，一些基米的创意很难流行起来**。

所以我的管理器做了**脚本集成**功能：

- 所有模组编辑脚本都放在 `script/mod_editor/` 目录下，是开放的 Python 文件；
- 在编辑 mod 界面，点击【运行脚本】，会弹出一个列表，列出所有可用的脚本；
- 选中脚本后点击【运行】，程序会在当前进程里加载并执行脚本，**不需要用户会 Python**；
- 脚本可以拿到“当前正在编辑的这个 mod”，自动对它做处理，比如批量改名、批量移动文件等。

这样：
- **对脚本作者**：写一个 Python 脚本，丢到 `script/mod_editor/` 目录，界面自动列出来，别人就能用；
- **对普通用户**：不需要会 Python，不需要装库，不需要敲命令，**把脚本当成“给界面加一个新按钮”来用就行**。

比如 `batch_rename_suit.py`（批量重命名套装）这个脚本：
- 自动找到当前 mod 中的套装文件夹（如 `pl027_0500`）；
- 通过字典解析出当前套装名（如 `精英·霜漂阿尔法`）；
- 弹出一个对话框，让你选择要替换成哪个套装；
- 自动把当前套装文件夹内所有相关文件/文件夹的编号段替换掉。

就算我是脚本大手写了一堆妙妙工具，用的时候找不到在哪也相当愁人。现在所有脚本都在界面里统一列出，点一下就能用，不用到处找文件。

---

## 二分排查：为什么 mod 管理器不能帮我做这个？

如果你装了一堆 mod，突然游戏崩溃了、闪退了，或者某个功能不正常了，你第一反应是什么？

**肯定是想知道是哪个 mod 导致的。**

最笨的办法是：一个个禁用，一个个测试，直到找到问题 mod。如果你装了 50 个 mod，最坏情况要测试 50 次。

稍微聪明一点的办法是：**二分排查**：
1. 先禁用一半 mod，看游戏是否正常；
2. 如果正常，说明问题在另一半；如果不正常，说明问题在这一半；
3. 继续对有问题的那一半进行二分，直到找到问题 mod。

这样最多只需要测试 log₂(50) ≈ 6 次就能找到问题。

**但问题是：手操二分排查太麻烦了。**

你要：
- 手动勾选/取消勾选一半 mod；
- 记住哪些是“这一半”、哪些是“那一半”；
- 测试完游戏，回来继续分下一半；
- 一不小心就搞混了，或者漏掉某个 mod。
呵呵，我已经删游戏重装了有懂得吗

我就一直在想：**为什么 mod 管理器不能给我实现这个功能？难道很难吗？**

逻辑上就是：
- 把当前启用的 mod 列表分成两半；
- 禁用一半，让你测试；
- 测试完告诉你结果，继续分下一半。

这明明就是一个很简单的算法，但很多管理器就是没有。所以我的管理器里直接内置了【批量禁用】→【二分法禁用】功能，一键帮你做二分排查，不用手操。

---

## 之前用过的 mod 不会没：批量导入无缝衔接狩技盒子

如果你之前一直在用狩技管理器，现在想换到这个管理器，不用担心：

**之前用过的 mod 不会丢失。**

我的管理器提供了【批量导入】→【从狩技盒子导入】功能：
- 选择你的狩技盒子存放 mod 的根目录；
- 程序会自动扫描所有序号文件夹（`1001`、`1002` 等），识别符合结构的 mod（有 `files` 和 `info.xml` 的）；
- 一次性导入到本管理器的 `mods/` 目录，尽量把原来的名字、作者等信息一起带过来。

你基本上只需要“指一下狩技的目录”，原来在狩技里的一整套 mod 就迁移进来了，不用一个个手动导。

---

## 分类标签：我想怎么分就怎么分

很多管理器只给你固定的几个分类，比如“服装”“武器”“UI”，没了。你想按功能分，它只给你“服装”；你想按状态分，它没有“测试中”；你想按作者分，它更没有。

我就想：**为什么不能让我自己定义标签？我想分“我喜欢的”“邦邦的”“神人逆天系列”，不行吗？**

这明明就是一个很简单的功能，但狩技管理器就是没有给。所以我的管理器里直接支持**完全自定义的分类标签**：
- 想创建多少标签就创建多少，想怎么命名就怎么命名；
- 每个 mod 可以打多个标签，按优先级排序显示；
- 可以添加、删除、重命名，还可以拖拽调整顺序；
- 在主界面按标签筛选，想找什么类型的 mod 一下就找到了。

这样你就不用再被固定的分类框住，想怎么组织你的 mod 就怎么组织。

---

呃呃了，说了这么多还没说我的管理器怎么用，以后录个视频吧，到时候要是录出来了（喜）就放下面了。